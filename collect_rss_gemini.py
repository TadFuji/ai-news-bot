import os
import json
import datetime
from rss_client import collect_from_rss_feeds
from ai_client import process_with_gemini
from config import NEWS_BOT_OUTPUT_DIR
from dotenv import load_dotenv

load_dotenv()

def filter_by_time(articles, hours=24):
    """Filter articles published within the last N hours."""
    cutoff = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=hours)
    filtered = []
    for a in articles:
        pub = a.get('published')
        if pub and pub >= cutoff:
            filtered.append(a)
    return filtered

def main():
    print("=== Hybrid News Collection Start ===")
    print("1. Fetching RSS Feeds...")
    articles = collect_from_rss_feeds()
    
    # Simple Time Filter (24h)
    print("2. Filtering by Time (24h)...")
    articles = filter_by_time(articles)
    print(f"-> {len(articles)} articles remaining.")
    
    if not articles:
        print("No recent articles found.")
        return

    print("3. Prioritizing AI-related articles...")
    from config import AI_KEYWORDS
    
    scored_articles = []
    for a in articles:
        # Title and summary search (case-insensitive)
        text = (a.get('title', '') + " " + a.get('summary', '')).lower()
        score = 0
        for kw in AI_KEYWORDS:
            if kw.lower() in text:
                score += 1
        
        # Keep score for sorting
        a['_relevance'] = score
        scored_articles.append(a)
    
    # Sort: First by having at least one keyword, then by published date
    # This ensures "AI news" comes first, even if slightly older than a general "Breaking News"
    scored_articles.sort(key=lambda x: (x['_relevance'] > 0, x.get('published', datetime.datetime.min) or datetime.datetime.min), reverse=True)
    
    # Take top 30 relevant/newest for Gemini
    input_articles = scored_articles[:30]
    print(f"-> Selected {len(input_articles)} articles for Gemini analysis (Priority: AI Relevance).")

    print("4. Processing with Gemini (AI Trend Analyst Mode)...")
    processed = process_with_gemini(input_articles)
    
    # Save as JSON (Legacy Format compatible with generators)
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M")
    filename = f"ai_news_{timestamp}.json"
    filepath = os.path.join(NEWS_BOT_OUTPUT_DIR, filename)
    
    if not os.path.exists(NEWS_BOT_OUTPUT_DIR):
        os.makedirs(NEWS_BOT_OUTPUT_DIR)
    
    # Save as JSON (Legacy Format compatible with generators)
    # Format: {"articles": [...]} for compatibility with distribute_daily.py
    output_data = {"articles": processed}
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(output_data, f, indent=2, ensure_ascii=False)
        
    print(f"✅ Saved Top 10 to: {filepath}")
    
    # Also save as Markdown for visibility
    # Format compatible with build_pages.py parse_markdown_news()
    md_filename = f"ai_news_{timestamp}.md"
    md_filepath = os.path.join(NEWS_BOT_OUTPUT_DIR, md_filename)
    
    # Get current JST time for the "updated" field
    jst = datetime.timezone(datetime.timedelta(hours=9))
    now_jst = datetime.datetime.now(jst)
    updated_str = now_jst.strftime("%Y年%m月%d日 %H:%M")
    
    with open(md_filepath, 'w', encoding='utf-8') as f:
        f.write(f"# AI News Top 10\n\n")
        f.write(f"**更新日時**: {updated_str} (JST)\n\n")
        f.write(f"Generated by Gemini 2.0 Flash (via RSS)\n\n")
        for i, item in enumerate(processed, 1):
            title = item.get('title_ja', item.get('title', 'No Title'))
            summary = item.get('summary_ja', item.get('summary', ''))
            category = item.get('category', '未分類')
            source = item.get('source', 'Unknown')
            url = item.get('url', '')
            # Format expected by build_pages.py:
            # ## N. Title
            # 
            # **カテゴリ**: Category
            # ...
            f.write(f"## {i}. {title}\n\n")
            f.write(f"**カテゴリ**: {category}\n\n")
            f.write(f"{summary}\n\n")
            f.write(f"- **出典**: {source}\n")
            f.write(f"- **URL**: {url}\n\n")
            
    print(f"✅ Saved Markdown to: {md_filepath}")

if __name__ == "__main__":
    main()
